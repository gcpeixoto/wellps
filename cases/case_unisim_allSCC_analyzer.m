%% Case: UNISIM - Constrained Clustering Analyzer
%
% This case analyses outcomes from the Peixoto's algorithms 
% for slope constrained clustering. 
%
% See Remark in wellps::case_unisim_allSCC.m. Part of this methodology was 
% aborted.
%
% 
% REQUIREMENT: files generated by wellps::case_unisim_allSCC_clustering.
%

%% INPUTS

% consider partitions with >= minel elements
minel = 10;

% limit analysis for clusters with >= minc members
minc = 2;

%% Reload data
fis = {'../mat/SCCC_connections.mat','../mat/SCCT_connections.mat',...
       '../mat/SCCPY_connections.mat','../mat/SCCNL_connections.mat'};
% if available. 
if unique(cellfun(@exist,fis)) == 2
    load('../mat/SCCC_connections.mat','SCCC_connections');
    load('../mat/SCCT_connections.mat','SCCT_connections');
    load('../mat/SCCPY_connections.mat','SCCPY_connections');
    load('../mat/SCCNL_connections.mat','SCCNL_connections');    
else
    error('Did you run wellps::case_unisim_allSCC_clustering.m?');
end

%% Grid reading
[G,PROPS] = buildModel('../benchmarks/unisim-I-D/eclipse/UNISIM_I_D_ECLIPSE.DATA');
G = computeGeometry(G);

%% Compute required parameters
P = computeParams(G,PROPS);

%% Log data

% log10(phiz) x log10(RQI); normalized averaging technique 
Log10PHIZ = P.Log10PHIZ(:); 
Log10RQIN = P.Log10RQIN(:);

%% Mapping
Ind = nan(prod(G.cartDims),1);
Ind(G.cells.indexMap) = 1:G.cells.num;

%% Load pre-computed partitionings 

codename = {'SCCC','SCCT','SCCPY','SCCNL'};

%% Plot 3D info

% Extract subgrid from the global grid based on the point indices of the
% connected components found by the SCC method  
% and plot property over the subgrid (e.g. FZI)
%
% EXAMPLE:
% Method: SCCC; partition: 1; connected component: 1
%{
Gi = extractSubgrid(G,Ind(SCCC_connections.connections{1}.globalCompVoxelInds{1})); % need inverse grid mapping
plotCellData(Gi,P.FZIN(SCCC_connections.connections{1}.globalCompVoxelInds{1})) % do not need grid mapping
%}


%% CLUSTER INTERSECTION ANALYSIS

% Check if there are intersections of clusters detected by each SCC method. 

% number of partitions
npc  = length(SCCC_connections.connections);
npct = length(SCCT_connections.connections);
nppy = length(SCCPY_connections.connections);
npnl = length(SCCNL_connections.connections);

% mark which method do has clusters to be analysed
goto_analysis = true(1,4);

% 'sccX_pc' are arrays storing, per partition, the indices of all the
% clusters whose number of elements is >= minc for the method 'X'.

% SCCC
sccc_pc = cell(npc,1);
for p = 1:npc
    
    if ~isempty(SCCC_connections.connections{p})
        aux = SCCC_connections.connections{p}.compSizes;        
        aux = find(aux >= minc);
        if ~isempty(aux)
            sccc_pc{p} = aux;
        end
    end                
end
% checking
if all(cellfun(@isempty,sccc_pc))
    goto_analysis(1) = false;    
else
   % store useful parts and associated clusters
   aux = find(~cellfun(@isempty,sccc_pc));
   aux2 = cell(numel(aux),2);
   for i = 1:numel(aux)       
       aux2{i,1} = aux(i);
       aux2{i,2} = sccc_pc{aux(i)};
   end
      
   sccc_pc = aux2;
end

% SCCT
scct_pc = cell(npct,1);
for p = 1:npct
    
    if ~isempty(SCCT_connections.connections{p})
        aux = SCCT_connections.connections{p}.compSizes;        
        aux = find(aux >= minc);
        if ~isempty(aux)
            scct_pc{p} = aux;
        end
    end                
end

% checking
if all(cellfun(@isempty,scct_pc))
    goto_analysis(2) = false;    
else
    % store useful parts and associated clusters
   aux = find(~cellfun(@isempty,scct_pc));
   aux2 = cell(numel(aux),2);
   for i = 1:numel(aux)
       aux2{i,1} = aux(i);
       aux2{i,2} = scct_pc{aux(i)};
   end
      
   scct_pc = aux2;
    
end

% SCCPY
sccpy_pc = cell(nppy,1);
for p = 1:nppy
    
    if ~isempty(SCCPY_connections.connections{p})
        aux = SCCPY_connections.connections{p}.compSizes;        
        aux = find(aux >= minc);
        if ~isempty(aux)
            sccpy_pc{p} = aux;
        end
    end                
end

% checking
if all(cellfun(@isempty,sccpy_pc))
    goto_analysis(3) = false;   
else
    % store useful parts and associated clusters
   aux = find(~cellfun(@isempty,sccpy_pc));
   aux2 = cell(numel(aux),2);
   for i = 1:numel(aux)
       aux2{i,1} = aux(i);
       aux2{i,2} = sccpy_pc{aux(i)};
   end
      
   sccpy_pc = aux2;
end

% SCCNL
sccnl_pc = cell(npnl,1);
for p = 1:npnl
    
    if ~isempty(SCCNL_connections.connections{p})
        aux = SCCNL_connections.connections{p}.compSizes;        
        aux = find(aux >= minc);
        if ~isempty(aux)
            sccnl_pc{p} = aux;
        end
    end                
end

% checking
if all(cellfun(@isempty,sccnl_pc))
    goto_analysis(4) = false;  
else
    % store useful parts and associated clusters
   aux = find(~cellfun(@isempty,sccnl_pc));
   aux2 = cell(numel(aux),2);
   for i = 1:numel(aux)
       aux2{i,1} = aux(i);
       aux2{i,2} = sccnl_pc{aux(i)};
   end
      
   sccnl_pc = aux2;
end

TO_ANALYSIS = {sccc_pc,scct_pc,sccpy_pc,sccnl_pc};
CONNS = {SCCC_connections,SCCT_connections,...
         SCCPY_connections,SCCNL_connections};
toa = find(goto_analysis);

% filter
stay = numel(toa);
for i = 1:stay
    fprintf('---> Keeping %s clustering to study.\n',codename{toa(i)});
    TO_STUDY.approach(i).name = codename{toa(i)};
    TO_STUDY.approach(i).partitionsID = TO_ANALYSIS{toa(i)}(:,1);
    TO_STUDY.approach(i).clustersID = TO_ANALYSIS{toa(i)}(:,2);
    TO_STUDY.approach(i).All = CONNS{toa(i)};
end

%{ 
% \TODO

TO_ANALYSIS = {sccc_pc,scct_pc,sccpy_pc,sccnl_pc};
CONNS = {SCCC_connections,SCCT_connections,...
         SCCPY_connections,SCCNL_connections};
toa = find(goto_analysis);

INTERSECTIONS = TO_ANALYSIS;

for i = toa
    for j = toa
        if i ~= j
            
            aux = [];
            
            Pi = TO_ANALYSIS{i}(:,1);
            Pj = TO_ANALYSIS{j}(:,1);
            
            np = length(Pi); nq = length(Pj); 
            
            for p = 1:np                                
                for q = 1:nq
                    
                    ip = cell2mat(Pi(p));
                    iq = cell2mat(Pj(q));
                    
                    Cp = TO_ANALYSIS{ip}(:,2);                                                                
                    Cq = TO_ANALYSIS{iq}(:,2);                                                                                                
                    
                    Clistp = cell2mat(Cp(p));
                    Clistq = cell2mat(Cq(q));
                    
                    nc = numel(Clistp); nd = numel(Clistq);
                                       
                    for c = 1:nc
                        for d = 1:nd
                            
                            cc = Clistp(c); 
                            cd = Clistq(d); 
                            
                            Ci = CONNS{i}.connections{ip}.globalCompVoxelInds{cc};
                            Cj = CONNS{j}.connections{iq}.globalCompVoxelInds{cd};
                            
                            if numel(Ci) == numel(Cj) & Ci == Cj
                                aux = [aux; [j,iq,cd]];
                                fprintf('%d %d %d\n',j,iq,cd);                                
                            end
                            
                        end
                    end
                    
                end
            end
            
        end
    end
end
%}    

%% 3D ANALYSIS FOR MAJOR CLUSTERS

napp = length(TO_STUDY.approach);

for a = 1%:napp
    
    Pa = cell2mat(TO_STUDY.approach(a).partitionsID);
       
    Ca = TO_STUDY.approach(a).clustersID;
    
    figure
    plotGrid(G, 1:G.cells.num,'FaceColor',[0.6,0.6,0.6], ...
    'FaceAlpha',0.05, 'EdgeColor',[0.6,0.6,0.6],'EdgeAlpha',0.)
    hold on 
    
    for p = 1:length(Pa)
        cvi = TO_STUDY.approach(a).All.connections{p}.globalCompVoxelInds{Ca{p}(1)};
        glob = Ind(cvi);
        globn = glob(~isnan(glob));
        Gi = extractSubgrid(G,globn);        
        plotCellData(Gi,P.FZIN(cvi));
        %Gi = extractSubgrid(G,Ind(cvi));        
        %plotCellData(Gi,P.FZIN(cvi));
        
    end
    

end
 

%% ANALYSIS BASED ON SLOPE AND R2
% Each partition computed considers the total number of cells of the
% original deck file and, hence, has more cells than the processed grid 
% model. Hence, there are too many unitary partitions or with no value. 
%
% The analysis based on slope and R2 will filter the partitions 
% that attend to the  




