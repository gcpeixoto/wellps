%% Case: UNISIM - Constrained Clustering Analyzer
%
% This case analyses outcomes from the Peixoto's algorithms 
% for slope constrained clustering. 
%
% See Remark in wellps::case_unisim_allSCC.m. Part of this methodology was 
% aborted.
%
% 
% REQUIREMENT: files generated by wellps::case_unisim_allSCC_clustering.
%

%% INPUTS

% analyse clusters with >= minc members
minc = 2;

%% Reload data
fis = {'../mat/SCCC_connections.mat','../mat/SCCT_connections.mat',...
       '../mat/SCCPY_connections.mat','../mat/SCCNL_connections.mat'};
% if available. 
if unique(cellfun(@exist,fis)) == 2
    load('../mat/SCCC_connections.mat','SCCC_connections');
    load('../mat/SCCT_connections.mat','SCCT_connections');
    load('../mat/SCCPY_connections.mat','SCCPY_connections');
    load('../mat/SCCNL_connections.mat','SCCNL_connections');    
else
    error('Did you run wellps::case_unisim_allSCC_clustering.m?');
end

%% Grid reading
[G,PROPS] = buildModel('../benchmarks/unisim-I-D/eclipse/UNISIM_I_D_ECLIPSE.DATA');
G = computeGeometry(G);

%% Compute required parameters
P = computeParams(G,PROPS);

%% Log data

% log10(phiz) x log10(RQI); normalized averaging technique 
Log10PHIZ = P.Log10PHIZ(:); 
Log10RQIN = P.Log10RQIN(:);

%% Mapping
Ind = nan(prod(G.cartDims),1);
Ind(G.cells.indexMap) = 1:G.cells.num;


%% Load pre-computed partitionings 

codename = {'SCCC','SCCT','SCCPY','SCCNL'};

%% Plot 3D info

% Extract subgrid from the global grid based on the point indices of the
% connected components found by the SCC method  
% and plot property over the subgrid (e.g. FZI)
%
% EXAMPLE:
% Method: SCCC; partition: 1; connected component: 1
%{
Gi = extractSubgrid(G,Ind(SCCC_connections.connections{1}.globalCompVoxelInds{1})); % need inverse grid mapping
plotCellData(Gi,P.FZIN(SCCC_connections.connections{1}.globalCompVoxelInds{1})) % do not need grid mapping
%}


%% CLUSTER ANALYSIS - FILTERING 

% number of partitions with (>= SCCC_connections.minel) elements (USEFUL PARTITIONS)
% It also considers partitions that do not have clusters (connected components)
npc  = length(SCCC_connections.connections);
npct = length(SCCT_connections.connections);
nppy = length(SCCPY_connections.connections);
npnl = length(SCCNL_connections.connections);
nup = [npc,npct,nppy,npnl];


% mark which method do has clusters to be analysed
goto_analysis = true(1,4);

% 'sccX_pc' are arrays storing, per partition, the indices of all the
% clusters whose number of elements is >= minc for the method 'X'.

% SCCC
sccc_pc = cell(npc,1);
for p = 1:npc
    
    if ~isempty(SCCC_connections.connections{p})
        aux = SCCC_connections.connections{p}.compSizes;        
        aux = find(aux >= minc);
        if ~isempty(aux)
            sccc_pc{p} = aux;
        end
    end                
end
% checking
if all(cellfun(@isempty,sccc_pc))
    goto_analysis(1) = false;    
else
   % store useful parts and associated clusters
   aux = find(~cellfun(@isempty,sccc_pc));
   aux2 = cell(numel(aux),2);
   for i = 1:numel(aux)       
       aux2{i,1} = aux(i);
       aux2{i,2} = sccc_pc{aux(i)};
   end
      
   sccc_pc = aux2;
end

% SCCT
scct_pc = cell(npct,1);
for p = 1:npct
    
    if ~isempty(SCCT_connections.connections{p})
        aux = SCCT_connections.connections{p}.compSizes;        
        aux = find(aux >= minc);
        if ~isempty(aux)
            scct_pc{p} = aux;
        end
    end                
end

% checking
if all(cellfun(@isempty,scct_pc))
    goto_analysis(2) = false;    
else
    % store useful parts and associated clusters
   aux = find(~cellfun(@isempty,scct_pc));
   aux2 = cell(numel(aux),2);
   for i = 1:numel(aux)
       aux2{i,1} = aux(i);
       aux2{i,2} = scct_pc{aux(i)};
   end
      
   scct_pc = aux2;
    
end

% SCCPY
sccpy_pc = cell(nppy,1);
for p = 1:nppy
    
    if ~isempty(SCCPY_connections.connections{p})
        aux = SCCPY_connections.connections{p}.compSizes;        
        aux = find(aux >= minc);
        if ~isempty(aux)
            sccpy_pc{p} = aux;
        end
    end                
end

% checking
if all(cellfun(@isempty,sccpy_pc))
    goto_analysis(3) = false;   
else
    % store useful parts and associated clusters
   aux = find(~cellfun(@isempty,sccpy_pc));
   aux2 = cell(numel(aux),2);
   for i = 1:numel(aux)
       aux2{i,1} = aux(i);
       aux2{i,2} = sccpy_pc{aux(i)};
   end
      
   sccpy_pc = aux2;
end

% SCCNL
sccnl_pc = cell(npnl,1);
for p = 1:npnl
    
    if ~isempty(SCCNL_connections.connections{p})
        aux = SCCNL_connections.connections{p}.compSizes;        
        aux = find(aux >= minc);
        if ~isempty(aux)
            sccnl_pc{p} = aux;
        end
    end                
end

% checking
if all(cellfun(@isempty,sccnl_pc))
    goto_analysis(4) = false;  
else
    % store useful parts and associated clusters
   aux = find(~cellfun(@isempty,sccnl_pc));
   aux2 = cell(numel(aux),2);
   for i = 1:numel(aux)
       aux2{i,1} = aux(i);
       aux2{i,2} = sccnl_pc{aux(i)};
   end
      
   sccnl_pc = aux2;
end

% number of effective partitions
neffep = [length(sccc_pc),length(scct_pc),length(sccpy_pc),length(sccnl_pc)];

TO_ANALYSIS = {sccc_pc,scct_pc,sccpy_pc,sccnl_pc};
CONNS = {SCCC_connections,SCCT_connections,...
         SCCPY_connections,SCCNL_connections};
toa = find(goto_analysis);

% filter
stay = numel(toa);
for i = 1:stay
    fprintf('---> Keeping %s clustering to study.\n',codename{toa(i)});
    TO_STUDY.approach(i).name = codename{toa(i)};
    TO_STUDY.approach(i).partitionsID = TO_ANALYSIS{toa(i)}(:,1);
    TO_STUDY.approach(i).clustersID = TO_ANALYSIS{toa(i)}(:,2);
    TO_STUDY.approach(i).All = CONNS{toa(i)};
end

%{ 
% CLUSTER INTERSECTION ANALYSIS \TODO
% Check if there are intersections of clusters detected by each SCC method. 

TO_ANALYSIS = {sccc_pc,scct_pc,sccpy_pc,sccnl_pc};
CONNS = {SCCC_connections,SCCT_connections,...
         SCCPY_connections,SCCNL_connections};
toa = find(goto_analysis);

INTERSECTIONS = TO_ANALYSIS;

for i = toa
    for j = toa
        if i ~= j
            
            aux = [];
            
            Pi = TO_ANALYSIS{i}(:,1);
            Pj = TO_ANALYSIS{j}(:,1);
            
            np = length(Pi); nq = length(Pj); 
            
            for p = 1:np                                
                for q = 1:nq
                    
                    ip = cell2mat(Pi(p));
                    iq = cell2mat(Pj(q));
                    
                    Cp = TO_ANALYSIS{ip}(:,2);                                                                
                    Cq = TO_ANALYSIS{iq}(:,2);                                                                                                
                    
                    Clistp = cell2mat(Cp(p));
                    Clistq = cell2mat(Cq(q));
                    
                    nc = numel(Clistp); nd = numel(Clistq);
                                       
                    for c = 1:nc
                        for d = 1:nd
                            
                            cc = Clistp(c); 
                            cd = Clistq(d); 
                            
                            Ci = CONNS{i}.connections{ip}.globalCompVoxelInds{cc};
                            Cj = CONNS{j}.connections{iq}.globalCompVoxelInds{cd};
                            
                            if numel(Ci) == numel(Cj) & Ci == Cj
                                aux = [aux; [j,iq,cd]];
                                fprintf('%d %d %d\n',j,iq,cd);                                
                            end
                            
                        end
                    end
                    
                end
            end
            
        end
    end
end
%}    


%% ANALYSIS OF SLOPE AND R2 OF USEFUL PARTITIONS

ncon = length(CONNS);
for i = 1:ncon     
    slopes = CONNS{i}.slope(1:nup(i));  
    R2 = CONNS{i}.R2(1:nup(i));  
    seps = CONNS{i}.seps;
        
    % I found some outliers with slope outside the margin here... 
    % Need to get rid of them
    points = find(1-seps <= slopes & slopes <= 1+seps);   
    slopes = slopes(points);     
    R2 = R2(points); 
    delta = 1:numel(points);
    
    % plot of slope distribution
    figure
    set(gca,'FontSize',14);
    hold on, box on    
    
    plot(delta,slopes,'o','MarkerEdgeColor',[0.5,0.5,0.5],'MarkerFaceColor',[0.5,0.5,0.5])            
    plot(delta,ones(1,numel(delta)),'k-')    
    plot(delta,ones(1,numel(delta))*(1-seps),'r--')    
    plot(delta,ones(1,numel(delta))*(1+seps),'r--')    
    xlim([-1,max(delta)+1])
    ylim([1-2*seps,1+2*seps])
    xlabel('$\gamma$','interpreter','latex')
    ylabel('$s_{\gamma}$','interpreter','latex')
    xticks([1,max(delta)])
    yticks([1-seps,1,1+seps])
    hold off
    fname = strcat('../tmp/slope_partitions',num2str(i),'.eps');
    print(fname,'-depsc2')
    
    % plot of R2 distribution
    figure 
    set(gca,'FontSize',14);
    hold on, box on         
    plot(delta,R2,'o','MarkerEdgeColor',[0.5,0.5,0.5],'MarkerFaceColor',[0.5,0.5,0.5])            
    plot(delta,ones(1,numel(delta))*mean(R2),'k-')    
    plot(delta,ones(1,numel(delta))*min(R2),'r--')    
    plot(delta,ones(1,numel(delta))*max(R2),'r--')    
    xlim([-0.5,max(delta)+0.5])
    ylim([min(R2)-0.1,max(R2)+0.1])
    xlabel('$\gamma$','interpreter','latex')
    ylabel('$R^2_{\gamma}$','interpreter','latex')
    xticks([1,max(delta)])
    yticks(mean(R2))
    hold off
    fname = strcat('../tmp/R2_partitions',num2str(i),'.eps');
    print(fname,'-depsc2')
    
    
    fprintf('-> "%s"\n',codename{i});
    fprintf('---> USEFUL PARTITIONS (# >= %d): %d \n',SCCC_connections.minel,numel(delta));        
          
end

%% PLOTS OF EFFECTIVE PARTITIONS

% Effective partitions are those that have connected clusters and 
% whose clusters has >= minc elements. 

% REMARK: We are going to exclude "SCCT" from the paper because it has the
% almost the same approach as SCCC
% The number of effective partitions per approach is given in the 
% array 'neffep'. However, for SCCNL, a few outliers were found in the
% SLOPE/R2 analysis and these partitions should be discounted in 'neffep(3)'.
%
% For instance, for the analysis of useful partitions with seps = 1e-1 and 
% minel >= 2 + effective partitions with minc >=2, neffep(4) = 9, but 
% we had 4 outliers. Then we must look at 'sccnl_pc' to check if, even with
% the removal of the outliers, how many partitions still keep the 'minc'
% constraint. In this test case, we end up with 5 effective partitions:
% [1,4,6,8,9].

% SAMPLE PARTITIONS
for a = [1,3,4]
            
    f = figure;
    plotGrid(G, 1:G.cells.num,'FaceColor',[0.6,0.6,0.6], ...
    'FaceAlpha',0.05, 'EdgeColor',[0.6,0.6,0.6],'EdgeAlpha',0.1)
    hold on, axis off vis3d, view([-96,43])
        
    if a == 1
        chosen_parts = [29,30,31];
    elseif a == 3
        chosen_parts = [8,9,10];
    elseif a == 4
        chosen_parts = [4,6,8]; % in paper: 2,3,4
    end
    
    cs = [145,76,69; 96,210,69; 0,0,167]/255; colormap(f,cs);
    icp = 1;    
    for cp = chosen_parts        
        part_cells = TO_STUDY.approach(a).All.partitioning{cp};            
        plotGrid(G,Ind(part_cells),'FaceColor',cs(icp,:));                
        icp = icp + 1;                
    end
    cbar = colorbar;
    cbar.Ticks = [0.33,0.66,0.99];
    if a == 4 
        chosen_parts = [2,3,4];
        cbar.TickLabels = num2cell(split(num2str(chosen_parts)));
    else
        cbar.TickLabels = num2cell(split(num2str(chosen_parts)));
    end
    cbar.FontSize = 14; 
    fname = strcat('../tmp/effective_partitions',num2str(a),'.eps');
    print(fname,'-depsc2')
            
end


% SAMPLE CLUSTERS
figure;
plotGrid(G, 1:G.cells.num,'FaceColor',[0.6,0.6,0.6], ...
    'FaceAlpha',0.05, 'EdgeColor',[0.6,0.6,0.6],'EdgeAlpha',0.1)
hold on, axis off vis3d, view([-201,20])

for a = [1,3,4]              

    % chooses two first clusters of each sample partition
    chosen_clusts = 1:2;              
            
    % SCCC (red tones)
    if a == 1
        chosen_parts = [29,30,31];       
        cs = [1,0,0; 0.8,0,0; 0.5,0,0];
        
    % SCCPY (green tones)  
    elseif a == 3
        chosen_parts = [8,9,10];        
        cs = [0,1,0; 0,0.8,0; 0,0.5,0];
    
    % SCCNL (blue tones)
    elseif a == 4
        chosen_parts = [4,6,8]; % in paper: 2,3,4
        cs = [0,0.2,1; 0,0.2,0.5; 0,0.2,0.2];
    end
                 
    % plot cluster location
    for cp = 1:length(chosen_parts)           
        for cc = 1:length(chosen_clusts)
            cvi = TO_STUDY.approach(a).All.connections{chosen_parts(cp)}.globalCompVoxelInds{chosen_clusts(cc)};                        
            plotGrid(G,Ind(cvi),'FaceColor',cs(cp,:));                      
        end
    end 
                
end
fname = strcat('../tmp/effective_clusters_locations_134','.eps');
print(fname,'-depsc2')
   

figure;
plotGrid(G, 1:G.cells.num,'FaceColor',[0.6,0.6,0.6], ...
    'FaceAlpha',0.05, 'EdgeColor',[0.6,0.6,0.6],'EdgeAlpha',0.1)
hold on, axis off vis3d, view([-201,20])
    
for a = [1,3,4]              

    % chooses two first clusters of each sample partition
    chosen_clusts = 1:2;              
            
    % SCCC (red tones)
    if a == 1
        chosen_parts = [29,30,31];       
        cs = [1,0,0; 0.8,0,0; 0.5,0,0];
        
    % SCCPY (green tones)  
    elseif a == 3
        chosen_parts = [8,9,10];        
        cs = [0,1,0; 0,0.8,0; 0,0.5,0];
    
    % SCCNL (blue tones)
    elseif a == 4
        chosen_parts = [4,6,8]; % in paper: 2,3,4
        cs = [0,0.2,1; 0,0.2,0.5; 0,0.2,0.2];
    end    
    
    % plot cluster with FZI field
    for cp = 1:length(chosen_parts)           
        for cc = 1:length(chosen_clusts)
            cvi = TO_STUDY.approach(a).All.connections{chosen_parts(cp)}.globalCompVoxelInds{chosen_clusts(cc)};                       
            glob = Ind(cvi);
            globn = glob(~isnan(glob));            
            Gi = extractSubgrid(G,globn);                    
            plotCellData(Gi,P.FZIN(cvi));   
            %centers = G.cells.centroids(globn,:);            
            cbar = colorbar;
            cbar.FontSize = 14;
        end
    end 
end

fname = strcat('../tmp/effective_clusters_fzi_134','.eps');
print(fname,'-depsc2')



%% PLOT FZI Field @UNISIM-1-D

figure 
active = find(~isnan(Ind));
FZIN = P.FZIN;  
FZIN = FZIN(:);
locs0 = find(FZIN > 0); 
FZIN0 = FZIN(locs0);
G0 = extractSubgrid(G,Ind(locs0));
plotCellData(G0,FZIN0,'EdgeColor','none')
axis off vis3d, view([-201,20])
lighting flat
cbar = colorbar;
cbar.FontSize = 14;
fname = strcat('../tmp/unisim1_fzi_nonzero','.eps');
print(fname,'-depsc2')

% Histogram FZI 
figure
histogram(FZIN0/max(FZIN0),'Normalization','probability','FaceColor',[0,0.2,0.5])
ylabel('$Prob(FZI_n > 0)$','interpreter','latex');
xlabel('$FZI_n > 0$','interpreter','latex');
set(gca,'FontSize',14);
fname = strcat('../tmp/unisim1_histogram_normalized_fzi_nonzero','.eps');
print(fname,'-depsc2')

figure;
d = G.cells.centroids(Ind(locs0),3);
plotCellData(G0, d,'EdgeColor',[0.5,0.5,0.5],'EdgeAlpha',0.5)
cbar = colorbar; cbar.FontSize = 14;
hold on, axis off vis3d, view([-201,20])
fname = strcat('../tmp/unisim1_depth','.eps');
print(fname,'-depsc2')
